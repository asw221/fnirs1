config_info.cpp:            fprintf(flog,"pop.sub[%d].rep[%d].dataname = %s\n",i,j,rep->dataname);
config_info.cpp:            fprintf(flog,"pop.sub[%d].rep[%d].designname = %s\n",i,j,rep->designname);
config_info.cpp:            fprintf(flog,"%s\n",rep->dataname);fflush(flog);
config_info.cpp:            fout = fopen(rep->dataname,"r");
config_info.cpp:                rep->Y = subsample_data(YY,N,&subN,sub->freq,sfreq);
config_info.cpp:                rep->N = subN;
config_info.cpp:                rep->Y = YY;
config_info.cpp:            compute_mean_sd(&mean,&sd,rep->Y,(const int)N);
config_info.cpp:                rep->Y[i] -= mean;  
config_info.cpp:                rep->Y[i] /= sd;         
config_info.cpp:            rep->P = PPP;
config_info.cpp:            rep->df_delta1 = 0.99999;
config_info.cpp:            rep->df_delta2 = 0.99999;
config_info.cpp:            fprintf(flog,"%s\n",rep->dataname);fflush(flog);
config_info.cpp:            fout = fopen(rep->dataname,"r");
config_info.cpp:            subN = rep->N;
config_info.cpp:                N = rep->N;
config_info.cpp:            for (int i=0;i<rep->N;i++)  
config_info.cpp:                   rep->Y[i] /= SD;     
config_info.cpp:                    mean += rep->Y[i];
config_info.cpp:                printf("mean = %lf %d %d\n",mean,N,rep->N);
config_info.cpp:            fout = fopen(rep->designname,"r");
config_info.cpp:            fprintf(flog,"%s\n",rep->designname);fflush(flog);
config_info.cpp:            rep->dim_design[0] = dim_design[0];
config_info.cpp:            rep->dim_design[1] = dim_design[1];
config_info.cpp:            rep->design = (double **)calloc(dim_design[0],sizeof(double *));
config_info.cpp:                rep->design[i] = (double *)calloc(dim_design[1],sizeof(double));
config_info.cpp:                    int ifs = fscanf(fout,"%lf ",&(rep->design[i][j]));
config_info.cpp:            rep->mhrf = 6;
config_info.cpp:            rep->X = convolve(rep->design,HRF,dim_design,dim_HRF);
config_info.cpp:                XXX = subsample_design(rep->X,dim_design[0],dim_design[1]*dim_HRF[1],&subN,sub->freq,sfreq); 
config_info.cpp:                free(rep->X);
config_info.cpp:                rep->X = XXX;
config_info.cpp:            rep->dim_X = (int *)calloc(2,sizeof(int));
config_info.cpp:            rep->dim_X[0] = subN;
config_info.cpp:            rep->dim_X[1] = dim_design[1]*dim_HRF[1];
config_info.cpp:            for (int j=0;j<rep->dim_X[1];j++) { // normalize
config_info.cpp:                for (int i=0;i<rep->dim_X[0];i++)
config_info.cpp:                    tmp = (tmp > rep->X[i*rep->dim_X[1]+j]) ? tmp:rep->X[i*rep->dim_X[1]+j];
config_info.cpp: //                  tmp += rep->X[i*rep->dim_X[1]+j]*rep->X[i*rep->dim_X[1]+j];
config_info.cpp:            for (int j=0;j<rep->dim_X[1];j++) { // normalize
config_info.cpp:                for (int i=0;i<rep->dim_X[0];i++)
config_info.cpp:                    rep->X[i*rep->dim_X[1]+j] /= max;
config_info.cpp: /*               for (int j=0;j<rep->dim_X[1];j++)
config_info.cpp:            for (int i=0;i<rep->dim_X[0];i++)
config_info.cpp:                rep->Y[i] += rep->X[i*rep->dim_X[1]+j];*/
config_info.cpp:            rep->dim_X[0] = N;
config_info.cpp:                rep->Y[i] = rep->Y[i+1] - rep->Y[i];
config_info.cpp:            for (int j=0;j<rep->dim_X[1];j++) { // normalize
config_info.cpp:                for (int i=0;i<rep->dim_X[0];i++)
config_info.cpp:                    rep->X[i*rep->dim_X[1]+j] = rep->X[(i+1)*rep->dim_X[1]+j] - rep->X[i*rep->dim_X[1]+j];
config_info.cpp:            rep->d_Y = (double *)calloc(rep->dim_X[0],sizeof(double));
config_info.cpp:            rep->dY = (int *)calloc(rep->dim_X[0],sizeof(int));
config_info.cpp:            for (int i=0;i<rep->dim_X[0];i++) {
config_info.cpp:                rep->d_Y[i] = 1;
config_info.cpp:                rep->dY[i] = 1;
config_info.cpp:            rep->pi = 0.95;
config_info.cpp:            rep->d_Ycnt = rep->dim_X[0];
config_info.cpp:            tmprep->dlmStruc = (sDLM *)calloc(tmprep->dim_X[0],sizeof(sDLM));
config_info.cpp:            for (int k=0;k<tmprep->dim_X[0];k++)
config_info.cpp:                tmprep->dlmStruc[k].a = (double *)calloc(dimsize,sizeof(double));
config_info.cpp:            for (int k=0;k<tmprep->dim_X[0];k++)
config_info.cpp:                tmprep->dlmStruc[k].m = (double *)calloc(dimsize,sizeof(double));
config_info.cpp:            for (int k=0;k<tmprep->dim_X[0];k++)
config_info.cpp:                tmprep->dlmStruc[k].C = (double *)calloc(dimsize*dimsize,sizeof(double));
config_info.cpp:    free(rep->dataname);
config_info.cpp:    free(rep->designname);
config_info.cpp:    for (int i=0;i<rep->dim_design[0];i++)
config_info.cpp:        free(rep->design[i]);
config_info.cpp:    free(rep->design);
config_info.cpp:    free(rep->pi_Y);
config_info.cpp:    free(rep->dY);
config_info.cpp:    free(rep->d_Y);
config_info.cpp:    free(rep->md_Y);
config_info.cpp:    free(rep->sd_Y);
config_info.cpp:    free(rep->Y);
config_info.cpp:    free(rep->precY);
config_info.cpp:    free(rep->eta);
config_info.cpp:    free(rep->delta);
config_info.cpp:    free(rep->beta);
config_info.cpp:    free(rep->Xbeta);
config_info.cpp:    free(rep->mXbeta);
config_info.cpp:    free(rep->Wdelta);
config_info.cpp:    free(rep->mWdelta);
config_info.cpp:    free(rep->Wm);
config_info.cpp:    free(rep->X);
config_info.cpp:    free(rep->W);
config_info.cpp:    free(rep->V);
config_info.cpp:    free(rep->Veta);
config_info.cpp:    free(rep->mVeta);
config_info.cpp:    free(rep->mdelta);
config_info.cpp:    free(rep->mdelta2);
config_info.cpp:    free(rep->std_res);
config_info.cpp:    free(rep->mean_res);
config_info.cpp:    free(rep->mean_d_Y);
config_info.cpp:    free(rep->mean_fit);
config_info.cpp:    free(rep->residuals);
config_info.cpp:    free(rep->residuals1);
config_info.cpp:    free(rep->residuals2);
config_info.cpp:    free(rep->residuals3);
config_info.cpp:    free(rep->residuals4);
config_info.cpp:    free(rep->residuals5);
config_info.cpp:    free(rep->prop_sd);
config_info.cpp:    free(rep->attempt);
config_info.cpp:    free(rep->accept);
config_info.cpp:    free(rep->knots);
config_info.cpp:    int len = rep->dim_X[0];
config_info.cpp:        free(rep->dlmStruc[k].a);
config_info.cpp:        free(rep->dlmStruc[k].m);
config_info.cpp:        free(rep->dlmStruc[k].C);
config_info.cpp:    free(rep->dlmStruc);
config_info.cpp:    free(rep->dim_X);    
config_info.cpp:    free(rep->dim_W);
config_info.cpp:    free(rep->dim_V);        
dlm021018.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlm021018.cpp:        e = rep->residuals3[t] - f;        
dlm021018.cpp:            ll += tden(rep->residuals3[t],f,Q,*n);
dlm021018.cpp:    P = rep->P;  
dlm021018.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlm021018.cpp:            f += rep->W[t*P+i]*dlmStruc[t].a[i];
dlm021018.cpp:                dlmStruc[t].R[i*P+j] = dlmStruc[t-1].C[i*P+j]/rep->df_delta1;
dlm021018.cpp:                Q += rep->W[t*P+i]*dlmStruc[t].R[i*P+j]*rep->W[t*P+j];
dlm021018.cpp:                A[i] += dlmStruc[t].R[i*P+j]*rep->W[t*P+j];
dlm021018.cpp:        e = rep->residuals3[t] - f;        
dlm021018.cpp://        *n =  *n*rep->df_delta2 + 1;
dlm021018.cpp:        dlmStruc[t].n = dlmStruc[t-1].n*rep->df_delta2 + 1;
dlm021018.cpp: //       printf("%lf %lf\n",*n,rep->df_delta2);
dlm021018.cpp://        *d = rep->df_delta2*(*d) + dlmStruc[t-1].S*e*e/Q;
dlm021018.cpp:        dlmStruc[t].d = rep->df_delta2*dlmStruc[t-1].d + dlmStruc[t-1].S*e*e/Q;
dlm021018.cpp://    n = rep->dim_X[0];
dlm021018.cpp://printf("new_n = %lf old_n = %lf\n",*n,(double)rep->dim_X[0]);fflush(stdout);
dlm021018.cpp:    for (int t=rep->dim_X[0]-2;t>=P;t--) {
dlm021018.cpp:            m[i] = dlmStruc[t].m[i] + rep->df_delta1*(rep->delta[(t+1)*P + i] - dlmStruc[t+1].a[i]);
dlm021018.cpp:        double tmp = 1-rep->df_delta1;
dlm021018.cpp:            err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,m,seed);
dlm021018.cpp:        rep->d_Y[t] = rep->df_delta2*rep->d_Y[t+1];
dlm021018.cpp: //       *n = (*n - 1)/rep->df_delta2; 
dlm021018.cpp:        rep->d_Y[t] += rgamma(0.5*(1-rep->df_delta2)*dlmStruc[t].n,0.5*dlmStruc[t].d,seed);
dlm021018.cpp:    int P = rep->P;
dlm021018.cpp:    W = rep->W;
dlm021018.cpp:    old_loglik = dlm_forward_filter_draw(rep,dlmStruc,&d,&n,(const int)Pmax,(const int)P,(const double)rep->df_delta2,(const double)rep->df_delta1,W);
dlm021018.cpp:    double range = rep->prop_sd[0];
dlm021018.cpp:    low = rep->df_delta1 - range;
dlm021018.cpp:    high = rep->df_delta1 + range;
dlm021018.cpp:    range = rep->prop_sd[1];
dlm021018.cpp:    low = rep->df_delta2 - range;
dlm021018.cpp:    high = rep->df_delta2 + range;
dlm021018.cpp:        prop_beta = rep->df_delta2;
dlm021018.cpp:        prop_delta = rep->df_delta1;
dlm021018.cpp:        prop_delta = rep->df_delta1;
dlm021018.cpp:        prop_beta = rep->df_delta2;
dlm021018.cpp:        calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)prop_P,P);
dlm021018.cpp:        W = rep->W;
dlm021018.cpp:        rep->df_delta1 = prop_delta;
dlm021018.cpp:        rep->df_delta2 = prop_beta;
dlm021018.cpp:        rep->P = prop_P;
dlm021018.cpp:        rep->dim_W[1] = rep->P;
dlm021018.cpp:            (rep->accept[flag])++;
dlm021018.cpp:        (rep->attempt[flag])++;
dlm021018.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
dlm021018.cpp:    int P = rep->P;
dlm021018.cpp:    int t = rep->dim_X[0]-1; 
dlm021018.cpp:        err = rmvtvec(&(rep->delta[t*P]),Var,P,n,dlmStruc[t].m,seed);
dlm021018.cpp:    rep->d_Y[t] = rgamma(n/2.,d/2.,seed);     
dlm021018.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlm.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlm.cpp:        e = rep->residuals3[t] - f;        
dlm.cpp:            ll += tden(rep->residuals3[t],f,Q,beta*n);
dlm.cpp:    P = rep->P;  
dlm.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlm.cpp:            f += rep->W[t*P+i]*dlmStruc[t].a[i];
dlm.cpp:                R[i*P+j] = dlmStruc[t-1].C[i*P+j]/rep->df_delta1;
dlm.cpp:                Q += rep->W[t*P+i]*R[i*P+j]*rep->W[t*P+j];
dlm.cpp:                A[i] += R[i*P+j]*rep->W[t*P+j];
dlm.cpp:        e = rep->residuals3[t] - f;        
dlm.cpp:        dlmStruc[t].n = dlmStruc[t-1].n*rep->df_delta2 + 1;
dlm.cpp:        dlmStruc[t].d = rep->df_delta2*dlmStruc[t-1].d + dlmStruc[t-1].S*e*e/Q;
dlm.cpp:    for (int t=rep->dim_X[0]-2;t>=P;t--) {
dlm.cpp:            m[i] = dlmStruc[t].m[i] + rep->df_delta1*(rep->delta[(t+1)*P + i] - dlmStruc[t+1].a[i]);
dlm.cpp:        double tmp = 1-rep->df_delta1;
dlm.cpp:            err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,m,seed);
dlm.cpp://        double Y = rep->df_delta2*rep->d_Y[t+1];
dlm.cpp://        Y += rgamma(0.5*(1-rep->df_delta2)*dlmStruc[t].n,0.5*dlmStruc[t].d,seed);
dlm.cpp://            rep->d_Y[t] = Y;
dlm.cpp:        rep->d_Y[t] = rep->df_delta2*rep->d_Y[t+1];
dlm.cpp:        rep->d_Y[t] += rgamma(0.5*(1-rep->df_delta2)*dlmStruc[t].n,0.5*dlmStruc[t].d,seed);
dlm.cpp:    int P = rep->P;
dlm.cpp:    W = rep->W;
dlm.cpp:    old_loglik = dlm_forward_filter_draw(rep,rep->dlmStruc,(const int)Pmax,(const int)P,(const double)rep->df_delta2,(const double)rep->df_delta1,W);
dlm.cpp:    double range = rep->prop_sd[0];
dlm.cpp:    low = rep->df_delta1 - range;
dlm.cpp:    high = rep->df_delta1 + range;
dlm.cpp:    range = rep->prop_sd[1];
dlm.cpp:    low = rep->df_delta2 - range;
dlm.cpp:    high = rep->df_delta2 + range;
dlm.cpp:        prop_beta = rep->df_delta2;
dlm.cpp:        prop_delta = rep->df_delta1;
dlm.cpp:        prop_delta = rep->df_delta1;
dlm.cpp:        prop_beta = rep->df_delta2;
dlm.cpp:        calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)prop_P,P);
dlm.cpp:        W = rep->W;
dlm.cpp:    new_loglik = dlm_forward_filter_draw(rep,rep->dlmStruc,(const int)Pmax,(const int)prop_P,(const double)prop_beta,(const double)prop_delta,W);
dlm.cpp://           new_log_prior = (0.999*(0.2*rep->dim_X[0]) - 1)*log(prop_delta) + (0.001*(0.2*rep->dim_X[0]) - 1)*log(1.-prop_delta);
dlm.cpp://            old_log_prior = (0.999*(0.2*rep->dim_X[0]) - 1)*log(rep->df_delta1) + (0.001*(0.2*rep->dim_X[0]) - 1)*log(1.-rep->df_delta1);
dlm.cpp://            new_log_prior = (0.8*(0.2*rep->dim_X[0]) - 1)*log(prop_beta) + (0.2*(0.2*rep->dim_X[0]) - 1)*log(1.-prop_beta);
dlm.cpp://            old_log_prior = (0.8*(0.2*rep->dim_X[0]) - 1)*log(rep->df_delta2) + (0.2*(0.2*rep->dim_X[0]) - 1)*log(1.-rep->df_delta2);
dlm.cpp:        rep->df_delta1 = prop_delta;
dlm.cpp:        rep->df_delta2 = prop_beta;
dlm.cpp:        rep->P = prop_P;
dlm.cpp:        rep->dim_W[1] = rep->P;
dlm.cpp:            (rep->accept[flag])++;
dlm.cpp:        (rep->attempt[flag])++;
dlm.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
dlm.cpp:    int P = rep->P;
dlm.cpp:    dlm_forward_filter(rep,rep->dlmStruc);
dlm.cpp:    int t = rep->dim_X[0]-1; 
dlm.cpp:        Var[i] = rep->dlmStruc[t].C[i];
dlm.cpp:        err = rmvtvec(&(rep->delta[t*P]),Var,P,rep->dlmStruc[t].n,rep->dlmStruc[t].m,seed);
dlm.cpp:    rep->d_Y[t] = rgamma(rep->dlmStruc[t].n/2.,rep->dlmStruc[t].d/2.,seed);     
dlm.cpp:    dlm_backward_sampling(rep,rep->dlmStruc,(const int)P,seed);
dlm.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlm.cpp:    sDLM *dlmStruc = (sDLM *)calloc(rep->dim_X[0],sizeof(sDLM));
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlm.cpp:    for (int k=0;k<rep->dim_X[0];k++)
dlmmcmc.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlmmcmc.cpp:        e = rep->residuals3[t] - f;        
dlmmcmc.cpp:            ll += tden(rep->residuals3[t],f,Q,dlmStruc[t].n);
dlmmcmc.cpp:    P = rep->P;  
dlmmcmc.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlmmcmc.cpp:            f += rep->W[t*P+i]*dlmStruc[t].a[i];
dlmmcmc.cpp:                dlmStruc[t].R[i*P+j] = dlmStruc[t-1].C[i*P+j]/rep->df_delta1;
dlmmcmc.cpp:                Q += rep->W[t*P+i]*dlmStruc[t].R[i*P+j]*rep->W[t*P+j];
dlmmcmc.cpp:                A[i] += dlmStruc[t].R[i*P+j]*rep->W[t*P+j];
dlmmcmc.cpp:        e = rep->residuals3[t] - f;        
dlmmcmc.cpp:        dlmStruc[t].n = dlmStruc[t-1].n*rep->df_delta2 + 1;
dlmmcmc.cpp:        dlmStruc[t].d = rep->df_delta2*dlmStruc[t-1].d + dlmStruc[t-1].S*e*e/Q;
dlmmcmc.cpp:    for (int t=rep->dim_X[0]-2;t>=P;t--) {
dlmmcmc.cpp:            m[i] = dlmStruc[t].m[i] + rep->df_delta1*(rep->delta[(t+1)*P + i] - dlmStruc[t+1].a[i]);
dlmmcmc.cpp:        double tmp = 1-rep->df_delta1;
dlmmcmc.cpp:            err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,m,seed);
dlmmcmc.cpp:    for (int t=rep->dim_X[0]-2;t>=P;t--) {
dlmmcmc.cpp:            m[i] = dlmStruc[t].m[i] + rep->df_delta1*(rep->delta[(t+1)*P + i] - dlmStruc[t+1].a[i]);
dlmmcmc.cpp:        double tmp = 1-rep->df_delta1;
dlmmcmc.cpp:            err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,m,seed);
dlmmcmc.cpp:        rep->d_Y[t] = rep->df_delta2*rep->d_Y[t+1];
dlmmcmc.cpp:        rep->d_Y[t] += rgamma(0.5*(1-rep->df_delta2)*dlmStruc[t].n,0.5*dlmStruc[t].d,seed);
dlmmcmc.cpp:    for (int t=P;t<rep->dim_X[0];t++) {
dlmmcmc.cpp:            ll = dens_gamma(rep->d_Y[t],0.5*dlmStruc[t-1].n,0.5*dlmStruc[t-1].d);
dlmmcmc.cpp:            ll += dens_gamma(rep->d_Y[t],0.5*dlmStruc[t-1].n,0.5*dlmStruc[t-1].d);
dlmmcmc.cpp:/*    for (int t=rep->dim_X[0]-1;t>=P;t--) {
dlmmcmc.cpp:        if (t == rep->dim_X[0]-1)
dlmmcmc.cpp:            ll = dens_gamma(rep->d_Y[t],0.5*dlmStruc[t].n,0.5*dlmStruc[t].d);
dlmmcmc.cpp:            ll += dens_gamma(rep->d_Y[t],0.5*(1-rep->df_delta2)*dlmStruc[t].n,0.5*dlmStruc[t].d);
dlmmcmc.cpp:    int P = rep->P;
dlmmcmc.cpp:    W = rep->W;
dlmmcmc.cpp:    calculate_residuals(rep,rep->P);
dlmmcmc.cpp:    range = rep->prop_sd[0];
dlmmcmc.cpp:    low = rep->df_delta1 - range;
dlmmcmc.cpp:    high = rep->df_delta1 + range;
dlmmcmc.cpp:    double save_delta1 = rep->df_delta1;   
dlmmcmc.cpp:    rep->df_delta1 = runif_atob(seed,low,high);
dlmmcmc.cpp:    low = rep->df_delta1 - range;
dlmmcmc.cpp:    high = rep->df_delta1 + range;
dlmmcmc.cpp:    double *delta = (double *)calloc(rep->dim_W[0]*maxP,sizeof(double));
dlmmcmc.cpp:    for (int i=0;i<rep->dim_W[0]*maxP;i++)
dlmmcmc.cpp:        delta[i] = rep->delta[i];
dlmmcmc.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlmmcmc.cpp:        (rep->accept[flag])++;
dlmmcmc.cpp:        rep->df_delta1 = save_delta1; 
dlmmcmc.cpp:        for (int i=0;i<rep->dim_W[0]*maxP;i++)
dlmmcmc.cpp:            rep->delta[i] = delta[i];
dlmmcmc.cpp:        calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlmmcmc.cpp:    (rep->attempt[flag])++;
dlmmcmc.cpp://    calculate_residuals(rep,rep->P);
dlmmcmc.cpp:    range = rep->prop_sd[1];
dlmmcmc.cpp:    low = rep->df_delta2 - range;
dlmmcmc.cpp:    high = rep->df_delta2 + range;
dlmmcmc.cpp:    double save_delta2 = rep->df_delta2;   
dlmmcmc.cpp:    rep->df_delta2 = runif_atob(seed,low,high);
dlmmcmc.cpp:    low = rep->df_delta2 - range;
dlmmcmc.cpp:    high = rep->df_delta2 + range;
dlmmcmc.cpp:/*    double *d_Y = (double *)calloc(rep->dim_X[0],sizeof(double));
dlmmcmc.cpp:    for (int i=0;i<rep->dim_X[0];i++)
dlmmcmc.cpp:        d_Y[i] = rep->d_Y[i];
dlmmcmc.cpp:        (rep->accept[flag])++;
dlmmcmc.cpp:        rep->df_delta2 = save_delta2; 
dlmmcmc.cpp://        for (int i=0;i<rep->dim_X[0];i++)
dlmmcmc.cpp://            rep->d_Y[i] = d_Y[i];
dlmmcmc.cpp:    (rep->attempt[flag])++;
dlmmcmc.cpp:    int P = rep->P;
dlmmcmc.cpp:    W = rep->W;
dlmmcmc.cpp:    old_loglik = dlm_forward_filter_draw(rep,dlmStruc,(const int)Pmax,(const int)P,(const double)rep->df_delta2,(const double)rep->df_delta1,W);
dlmmcmc.cpp:    double range = rep->prop_sd[0];
dlmmcmc.cpp:    low = rep->df_delta1 - range;
dlmmcmc.cpp:    high = rep->df_delta1 + range;
dlmmcmc.cpp:    range = rep->prop_sd[1];
dlmmcmc.cpp:    low = rep->df_delta2 - range;
dlmmcmc.cpp:    high = rep->df_delta2 + range;
dlmmcmc.cpp:        prop_beta = rep->df_delta2;
dlmmcmc.cpp:        prop_delta = rep->df_delta1;
dlmmcmc.cpp:        prop_delta = rep->df_delta1;
dlmmcmc.cpp:        prop_beta = rep->df_delta2;
dlmmcmc.cpp:        calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)prop_P,P);
dlmmcmc.cpp:        W = rep->W;
dlmmcmc.cpp:    rep->df_delta2 = prop_beta;
dlmmcmc.cpp:        rep->df_delta1 = prop_delta;
dlmmcmc.cpp:        rep->df_delta2 = prop_beta;
dlmmcmc.cpp:        rep->P = prop_P;
dlmmcmc.cpp:        rep->dim_W[1] = rep->P;
dlmmcmc.cpp:            (rep->accept[flag])++;
dlmmcmc.cpp:        (rep->attempt[flag])++;
dlmmcmc.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
dlmmcmc.cpp:    int P = rep->P;
dlmmcmc.cpp:    int t = rep->dim_X[0]-1; 
dlmmcmc.cpp:        err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,dlmStruc[t].m,seed);
dlmmcmc.cpp:    rep->d_Y[t] = rgamma(dlmStruc[t].n/2.,dlmStruc[t].d/2.,seed);     
dlmmcmc.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlmmcmc.cpp:    int P = rep->P;
dlmmcmc.cpp:    int t = rep->dim_X[0]-1; 
dlmmcmc.cpp:        err = rmvtvec(&(rep->delta[t*P]),Var,P,dlmStruc[t].n,dlmStruc[t].m,seed);
dlmmcmc.cpp://    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
dlmmcmc.cpp: //   int P = rep->P;
dlmmcmc.cpp: //   int t = rep->dim_X[0]-1; 
dlmmcmc.cpp:        err = rmvtvec(&(rep->delta[t*P]),Var,P,n,dlmStruc[t].m,seed);
dlmmcmc.cpp: //   rep->d_Y[t] = rgamma(dlmStruc[t].n/2.,dlmStruc[t].d/2.,seed);     
dlmmcmc.cpp:    double ll = dlm_backward_sampling_delta2(rep,dlmStruc,(const int)rep->P);
dlmmcmc.cpp://    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
hrfold.cpp:    double new_m = rnorm(rep->mhrf,rep->prop_sd[2],seed);
hrfold.cpp:    rep->attempt[2] += 1;
hrfold.cpp:    old_prior = (6-1)*log(rep->mhrf) - 1*rep->mhrf;
hrfold.cpp:    for (int i=0;i<rep->dim_X[0];i++) {
hrfold.cpp:        double res = rep->residuals[i];
hrfold.cpp:        old_loglik += dnorm(&res,&(rep->d_Y[i]),1);
hrfold.cpp:    X = convolve(rep->design,HRF,rep->dim_design,dim_HRF);
hrfold.cpp:        XXX = subsample_design(X,rep->dim_design[0],rep->dim_design[1]*dim_HRF[1],&subN,50,5); 
hrfold.cpp:    for (int j=0;j<rep->dim_X[1];j++) { // normalize
hrfold.cpp:        for (int i=0;i<rep->dim_X[0];i++)
hrfold.cpp:            tmp = (tmp > XXX[i*rep->dim_X[1]+j]) ? tmp:XXX[i*rep->dim_X[1]+j];
hrfold.cpp:    for (int j=0;j<rep->dim_X[1];j++) { // normalize
hrfold.cpp:        for (int i=0;i<rep->dim_X[0];i++)
hrfold.cpp:           XXX[i*rep->dim_X[1]+j] /= max;
hrfold.cpp:    calAx(rep->Xbeta,XXX,rep->beta,(const int)rep->dim_X[0],(const int)rep->dim_X[1]);
hrfold.cpp:    calculate_residuals(rep,rep->P);
hrfold.cpp:    for (int i=0;i<rep->dim_X[0];i++) {
hrfold.cpp:        double res = rep->residuals[i];//printf("res = %lf\n",res);fflush(NULL);
hrfold.cpp:        new_loglik += dnorm(&res,&(rep->d_Y[i]),1);
hrfold.cpp:        rep->accept[2] += 1;
hrfold.cpp:        rep->mhrf = new_m;
hrfold.cpp:        copydouble(rep->X,XXX,(const int)rep->dim_X[0]*rep->dim_X[1]);
hrfold.cpp:        calAx(rep->Xbeta,rep->X,rep->beta,(const int)rep->dim_X[0],(const int)rep->dim_X[1]);
hrfold.cpp:        calculate_residuals(rep,rep->P);
knots2.cpp:    knots = (double *)calloc(rep->nKnots,sizeof(double));
knots2.cpp:    knots2 = (double *)calloc(rep->nKnots,sizeof(double));
knots2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:        calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:        calculate_marginal_residuals(rep,rep->P);
knots2.cpp:        for (i=0;i<rep->P;i++)
knots2.cpp:            Qinv[i] = rep->d_Y[i];
knots2.cpp:        for (i=rep->P;i<rep->dim_V[0];i++)
knots2.cpp:        for (i=0;i<rep->dim_X[0];i++)
knots2.cpp:            old_like += log(Qinv[i])+Qinv[i]*rep->residuals[i]*rep->residuals[i];
knots2.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:    for (i=0;i<rep->nKnots;i++)
knots2.cpp:        knots[i] = rep->knots[i];
knots2.cpp:    V = (double *)calloc(rep->dim_V[0]*rep->dim_V[1],sizeof(double));
knots2.cpp:    eta = (double *)calloc(rep->dim_V[1],sizeof(double));
knots2.cpp:    eta2 = (double *)calloc(rep->dim_V[1],sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots2.cpp:        eta[i] = rep->eta[i];
knots2.cpp:    j = runiform_n(rep->nKnots-sdegree*2,seed) + sdegree;    
knots2.cpp:        knots[j] = rnorm(knots[j],rep->prop_sd[3],seed);  // propose knot location
knots2.cpp:        for (i = sdegree;i<rep->nKnots-sdegree;i++){
knots2.cpp:        (rep->attempt[3])++;
knots2.cpp:        if (knots[j] > 0 && knots[j] < rep->dim_V[0]-1) {  // ensure knot is still interior knot
knots2.cpp:            for (i=0;i<rep->nKnots;i++)
knots2.cpp:            for (i=0;i<rep->dim_V[1];i++)
knots2.cpp:            for (i=0;i<rep->nKnots-sdegree-1;i++) {  // reorder knots so their locations are sequential
knots2.cpp:                for (k=i+1;k<rep->nKnots-sdegree;k++) {
knots2.cpp:            for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:                for (k=0;k<rep->dim_V[1];k++)
knots2.cpp:                    V[i*rep->dim_V[1]+k] = 0;
knots2.cpp:            for (i=0;i<rep->dim_V[0];i++) {  // create new bspline basis
knots2.cpp:                bsplinebasis(0,0,sdegree,data[i],knots2,rep->nKnots,&V[i*rep->dim_V[1]]);
knots2.cpp:            calAx(rep->Veta,V,eta2,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]));
knots2.cpp:            calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:            calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:            int P = rep->dim_W[1];
knots2.cpp:            calculate_marginal_residuals(rep,rep->P);
knots2.cpp:            for (i=0;i<rep->P;i++)
knots2.cpp:                Qinv[i] = rep->d_Y[i];
knots2.cpp:            for (i=rep->P;i<rep->dim_V[0];i++)
knots2.cpp:            for (i=0;i<rep->dim_X[0];i++)
knots2.cpp:                new_like += log(Qinv[i]) + Qinv[i]*rep->residuals[i]*rep->residuals[i];
knots2.cpp:                (rep->accept[3])++;
knots2.cpp:                rep->knots[j] = knots[j];
knots2.cpp://                rep->eta[j] = eta[j];
knots2.cpp:                knots[j] = rep->knots[j];
knots2.cpp://                eta[j] = rep->eta[j];
knots2.cpp:            knots[j] = rep->knots[j];
knots2.cpp://            eta[j] = rep->eta[j];
knots2.cpp:        for (i=0;i<rep->nKnots-sdegree-1;i++) {
knots2.cpp:            for (k=i+1;k<rep->nKnots-sdegree;k++) {
knots2.cpp:                if (rep->knots[k] < rep->knots[i]) {
knots2.cpp:                    tmp = rep->knots[k];
knots2.cpp:                    rep->knots[k] = rep->knots[i];
knots2.cpp:                    rep->knots[i] = tmp;
knots2.cpp:                    tmp = rep->eta[k];
knots2.cpp:                    rep->eta[k] = rep->eta[i];
knots2.cpp:                    rep->eta[i] = tmp;
knots2.cpp://printf("nKnots - sdegree = %d dim_V[1] = %d\n",rep->nKnots-sdegree,rep->dim_V[1]);
knots2.cpp:        for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:            for (k=0;k<rep->dim_V[1];k++)
knots2.cpp:                rep->V[i*rep->dim_V[1]+k] = 0;
knots2.cpp:        for (i=0;i<rep->dim_V[0];i++) {  // create new bspline basis
knots2.cpp:            bsplinebasis(0,0,sdegree,data[i],rep->knots,rep->nKnots,&rep->V[i*rep->dim_V[1]]);
knots2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]));
knots2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp://    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp://    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp://    calculate_residuals(rep,rep->P);
knots2.cpp:    //calculate_marginal_residuals(rep,rep->P);
knots2.cpp:    partial_likelihood = (double *)calloc(rep->nKnots-2*sdegree,sizeof(double));
knots2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    double *tmpVeta = rep->Veta;
knots2.cpp:    if (rep->nKnots-2*sdegree > 0) {
knots2.cpp:        knots = (double *)calloc(rep->nKnots-1,sizeof(double));
knots2.cpp:        eta = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots2.cpp:        V = (double *)calloc(rep->dim_V[0]*(rep->dim_V[1]-1),sizeof(double));
knots2.cpp:        Veta = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:        W = (double *)calloc(rep->dim_W[0]*rep->dim_W[1],sizeof(double));
knots2.cpp:        Wm = (double *)calloc(rep->dim_W[0],sizeof(double)); 
knots2.cpp://        for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://            V[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots2.cpp:        for (i=0;i<rep->nKnots-2*sdegree;i++) {
knots2.cpp:            for (j=0;j<rep->dim_V[0];j++)
knots2.cpp:                for (k=0;k<rep->dim_V[1]-1;k++)
knots2.cpp:                    V[j*(rep->dim_V[1]-1)+k] = 0;
knots2.cpp:            calAx(Veta,V,eta,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]-1));
knots2.cpp:            rep->Veta = Veta;
knots2.cpp:            calW(rep->W,rep->Y,rep->Xbeta,Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:            calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:            calculate_marginal_residuals(rep,rep->P);
knots2.cpp:            for (j=0;j<rep->P;j++)
knots2.cpp:                Qinv[j] = rep->d_Y[j];
knots2.cpp:            for (j=rep->P;j<rep->dim_V[0];j++)
knots2.cpp:            for (j=0;j<rep->dim_X[0];j++) {
knots2.cpp:                partial_likelihood[i] += log(Qinv[j]) + Qinv[j]*rep->residuals[j]*rep->residuals[j];
knots2.cpp://        for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:    rep->Veta = tmpVeta;
knots2.cpp:    if (rep->nKnots-2*sdegree > 0) {
knots2.cpp:        for (i=1;i<rep->nKnots-2*sdegree;i++) {
knots2.cpp:        for (i=0;i<rep->nKnots-2*sdegree;i++) {
knots2.cpp:        for (i=1;i<rep->nKnots-2*sdegree;i++)
knots2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    position = runif_atob(seed,0,rep->dim_V[0]-1);
knots2.cpp:    for (i = sdegree;i<rep->nKnots-sdegree;i++){
knots2.cpp:        if (fabs(position-rep->knots[i]) < 0.1) {
knots2.cpp:    VV = (double *)calloc(rep->dim_V[0]*(rep->dim_V[1]+1),sizeof(double));
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        VV[i] = (double *)calloc(rep->dim_V[1]+1,sizeof(double));
knots2.cpp:    teta = (double *)calloc(rep->dim_V[1]+1,sizeof(double));
knots2.cpp:    tknots = (double *)calloc(rep->nKnots+1,sizeof(double));
knots2.cpp: //   free(rep->eta);
knots2.cpp:    teta[pos_idx] = rnorm(0,1/sqrt(rep->preceta),seed);
knots2.cpp:    (rep->dim_V[1])++;
knots2.cpp:    (rep->nKnots)++;
knots2.cpp:    rep->eta = (double *)realloc(rep->eta,sizeof(double)*(rep->dim_V[1]));
knots2.cpp://    rep->eta = (double *)calloc(rep->dim_V[1]+1,sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots2.cpp:        rep->eta[i] = teta[i];
knots2.cpp://    free(rep->knots);
knots2.cpp://    rep->knots = (double *)calloc(rep->nKnots+1,sizeof(double));
knots2.cpp:    rep->knots = (double *)realloc(rep->knots,sizeof(double)*(rep->nKnots));
knots2.cpp:    for (i=0;i<rep->nKnots;i++)
knots2.cpp:        rep->knots[i] = tknots[i];
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        free(rep->V[i]);
knots2.cpp:    //      free(rep->V);
knots2.cpp:    //      rep->V = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:        rep->V = (double *)realloc(rep->V,rep->dim_V[0]*rep->dim_V[1]*sizeof(double));
knots2.cpp://    rep->V[i] = (double *)calloc(rep->dim_V[1],sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++) {
knots2.cpp:        for (j=0;j<rep->dim_V[1];j++) {
knots2.cpp:            rep->V[i*rep->dim_V[1]+j] = VV[i*rep->dim_V[1]+j];
knots2.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        free(rep->J[i]);
knots2.cpp://    free(rep->J);
knots2.cpp://    rep->J = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots2.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots2.cpp: //       rep->J[i] = (double *)realloc(rep->J[i],rep->dim_V[1]*sizeof(double));
knots2.cpp://    rep->J[i] = (double *)calloc(rep->dim_V[1],sizeof(double));
knots2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
knots2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:    calculate_marginal_residuals(rep,rep->P);
knots2.cpp:    for (i=0;i<rep->P;i++)
knots2.cpp:        Qinv[i] = rep->d_Y[i];
knots2.cpp:    for (i=rep->P;i<rep->dim_V[0];i++)
knots2.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots2.cpp:        *full_likelihood += log(Qinv[i]) + Qinv[i]*rep->residuals[i]*rep->residuals[i];
knots2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    remove = (int)rmultinomial(death_rate,(long)(rep->nKnots-2*sdegree),seed);
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        free(rep->V[i]);
knots2.cpp://    free(rep->V);
knots2.cpp://    rep->V = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots2.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:        rep->V = (double *)realloc(rep->V,rep->dim_V[0]*(rep->dim_V[1]-1)*sizeof(double));
knots2.cpp://    rep->V[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        free(rep->J[i]);
knots2.cpp://    free(rep->J);
knots2.cpp://    rep->J = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots2.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp://        rep->J[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots2.cpp:    eta = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots2.cpp:    tknots = (double *)calloc(rep->nKnots-1,sizeof(double));
knots2.cpp:    remove_knot(rep,rep->V,eta,tknots,4,remove);
knots2.cpp:    (rep->nKnots)--;
knots2.cpp:    (rep->dim_V[1])--;
knots2.cpp://    free(rep->eta);
knots2.cpp://    rep->eta = (double *)calloc(rep->dim_V[1],sizeof(double));
knots2.cpp:    rep->eta = (double *)realloc(rep->eta,rep->dim_V[1]*sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots2.cpp:        rep->eta[i] = eta[i];
knots2.cpp://    free(rep->knots);
knots2.cpp://    rep->knots = (double *)calloc(rep->nKnots,sizeof(double));
knots2.cpp:    rep->knots = (double *)realloc(rep->knots,rep->nKnots*sizeof(double));
knots2.cpp:    for (i=0;i<rep->nKnots;i++)
knots2.cpp:        rep->knots[i] = tknots[i];
knots2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
knots2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:    calculate_marginal_residuals(rep,rep->P);
knots2.cpp:    for (i=0;i<rep->P;i++)
knots2.cpp:        Qinv[i] = rep->d_Y[i];
knots2.cpp:    for (i=rep->P;i<rep->dim_V[0];i++)
knots2.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots2.cpp:        *full_likelihood += log(Qinv[i]) + Qinv[i]*rep->residuals[i]*rep->residuals[i];
knots2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp://    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:    calculate_marginal_residuals(rep,rep->P);
knots2.cpp:    for (i=0;i<rep->P;i++)
knots2.cpp:        Qinv[i] = rep->d_Y[i];
knots2.cpp:    for (i=rep->P;i<rep->dim_V[0];i++)
knots2.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots2.cpp:        full_likelihood += log(Qinv[i]) + Qinv[i]*rep->residuals[i]*rep->residuals[i];
knots2.cpp:        death_rate = (double *)calloc(rep->nKnots-2*sdegree,sizeof(double));
knots2.cpp:        else if (rep->nKnots-sdegree >= max_knots)
knots2.cpp:            if (rep->nKnots-2*sdegree > 1) 
knots2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
knots2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots2.cpp: //   calculate_marginal_residuals(rep,rep->P);
knots2.cpp: //   calculate_residuals(rep,rep->P);
knots2.cpp:    nKnots = rep->nKnots-2*sdegree;
knots2.cpp:        if (rep->nKnots==0)
knots2.cpp:    for (i=0;i<rep->nKnots;i++) {
knots2.cpp:            knots[k] = rep->knots[i];
knots2.cpp:    for (j=0;j<rep->dim_V[1];j++) {
knots2.cpp:            eta[k] = rep->eta[j];
knots2.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++) {
knots2.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,rep->nKnots-1,&V[i*(rep->dim_V[1]-1)]);
knots2.cpp:    for (i=0;i<rep->nKnots;i++) {
knots2.cpp:        if (rep->knots[i] < position) {
knots2.cpp:            knots[i] = rep->knots[i];
knots2.cpp://            printf("i = %d %lf %lf\n",i,rep->knots[i],rep->knots[i+1]);fflush(stdout);
knots2.cpp:    for (j=i;j<rep->nKnots;j++)
knots2.cpp:        knots[j+1] = rep->knots[j];
knots2.cpp:        eta[i] = rep->eta[i];
knots2.cpp:    for (i=k;i<rep->dim_V[1]+1;i++)
knots2.cpp:        eta[i] = rep->eta[i-1];
knots2.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:    nKnots = rep->nKnots+1;
knots2.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots2.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,nKnots,&V[i*(rep->dim_V[1]+1)]);
knots.cpp:    knots = (double *)calloc(rep->nKnots,sizeof(double));
knots.cpp:    knots2 = (double *)calloc(rep->nKnots,sizeof(double));
knots.cpp:    calculate_residuals(rep,rep->P);
knots.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots.cpp:        old_like += rep->d_Y[i]*rep->residuals[i]*rep->residuals[i];
knots.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots.cpp:    for (i=0;i<rep->nKnots;i++)
knots.cpp:        knots[i] = rep->knots[i];
knots.cpp:    eta = (double *)calloc(rep->dim_V[1],sizeof(double));
knots.cpp:    eta2 = (double *)calloc(rep->dim_V[1],sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots.cpp:        eta[i] = rep->eta[i];
knots.cpp:    j = runiform_n(rep->nKnots-sdegree*2,seed) + sdegree;    
knots.cpp:        knots[j] = rnorm(knots[j],rep->prop_sd[3],seed);  // propose knot location
knots.cpp:        for (i = sdegree;i<rep->nKnots-sdegree;i++){
knots.cpp:        (rep->attempt[3])++;
knots.cpp:        if (knots[j] > 0 && knots[j] < rep->dim_V[0]-1) {  // ensure knot is still interior knot
knots.cpp:            for (i=0;i<rep->nKnots;i++)
knots.cpp:            for (i=0;i<rep->dim_V[1];i++)
knots.cpp:            for (i=sdegree;i<rep->nKnots-sdegree-1;i++) {  // reorder knots so their locations are sequential
knots.cpp:                for (k=i+1;k<rep->nKnots-sdegree;k++) {
knots.cpp:            for (i=0;i<rep->dim_V[0]*rep->dim_V[1];i++)
knots.cpp:                    rep->V[i] = 0;
knots.cpp:            for (i=0;i<rep->dim_V[0];i++)   // create new bspline basis
knots.cpp:                bsplinebasis(0,0,sdegree,data[i],knots2,rep->nKnots,&(rep->V[i*rep->dim_V[1]]));
knots.cpp:            calAx(rep->Veta,rep->V,eta2,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]));
knots.cpp:            calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots.cpp:            calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots.cpp:            calculate_residuals(rep,rep->P);
knots.cpp:           for (i=0;i<rep->dim_X[0];i++)
knots.cpp:                new_like += rep->d_Y[i]*rep->residuals[i]*rep->residuals[i];
knots.cpp:                (rep->accept[3])++;
knots.cpp:                for (i=0;i<rep->dim_V[1];i++)
knots.cpp:                    rep->eta[i] = eta2[i];
knots.cpp:                for (i=0;i<rep->nKnots;i++)
knots.cpp:                    rep->knots[i] = knots2[i];
knots.cpp:                for (i=0;i<rep->dim_V[0]*rep->dim_V[1];i++)
knots.cpp:                    rep->V[i] = 0;
knots.cpp:                for (i=0;i<rep->dim_V[0];i++)   // create new bspline basis
knots.cpp:                    bsplinebasis(0,0,sdegree,data[i],rep->knots,rep->nKnots,&rep->V[i*rep->dim_V[1]]);
knots.cpp:                calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]));
knots.cpp:                calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
knots.cpp:                calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots.cpp:                calculate_residuals(rep,rep->P);
knots.cpp:    partial_likelihood = (double *)calloc(rep->nKnots-2*sdegree,sizeof(double));
knots.cpp:    if (rep->nKnots-2*sdegree > 0) {
knots.cpp:        knots = (double *)calloc(rep->nKnots-1,sizeof(double));
knots.cpp:        eta = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots.cpp:        V = (double *)calloc(rep->dim_V[0]*(rep->dim_V[1]-1),sizeof(double));
knots.cpp:        Veta = (double *)calloc(rep->dim_V[0],sizeof(double));
knots.cpp:        W = (double *)calloc(rep->dim_W[0]*rep->dim_W[1],sizeof(double));
knots.cpp:        Wdelta = (double *)calloc(rep->dim_W[0],sizeof(double)); 
knots.cpp://        for (i=0;i<rep->dim_V[0];i++)
knots.cpp://            V[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots.cpp:        for (i=0;i<rep->nKnots-2*sdegree;i++) {
knots.cpp:            for (j=0;j<rep->dim_V[0];j++)
knots.cpp:                for (k=0;k<rep->dim_V[1]-1;k++)
knots.cpp:                    V[j*(rep->dim_V[1]-1)+k] = 0;
knots.cpp:            calAx(Veta,V,eta,(const int)rep->dim_V[0],(const int)(rep->dim_V[1]-1));
knots.cpp:            int P = rep->dim_W[1];
knots.cpp:            calW(W,rep->Y,rep->Xbeta,Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],P);
knots.cpp:            calWdelta(Wdelta,W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots.cpp:            for (j=0;j<rep->dim_X[0];j++) {
knots.cpp:                    rep->residuals[j] = rep->Y[j] - Veta[j] - rep->Xbeta[j];
knots.cpp:                    rep->residuals[j] = rep->Y[j] - Veta[j] - Wdelta[j] - rep->Xbeta[j];
knots.cpp:            for (j=0;j<rep->dim_X[0];j++)
knots.cpp:                partial_likelihood[i] += rep->d_Y[j]*rep->residuals[j]*rep->residuals[j];
knots.cpp://        for (i=0;i<rep->dim_V[0];i++)
knots.cpp:    if (rep->nKnots-2*sdegree > 0) {
knots.cpp:        for (i=1;i<rep->nKnots-2*sdegree;i++) {
knots.cpp:        for (i=0;i<rep->nKnots-2*sdegree;i++) {
knots.cpp:        for (i=1;i<rep->nKnots-2*sdegree;i++)
knots.cpp:    position = runif_atob(seed,0,rep->dim_V[0]-1);
knots.cpp:    for (i = sdegree;i<rep->nKnots-sdegree;i++){
knots.cpp:        if (fabs(position-rep->knots[i]) < 0.0001) {
knots.cpp:            position = runif_atob(seed,0,rep->dim_V[0]-1);
knots.cpp:    VV = (double *)calloc(rep->dim_V[0]*(rep->dim_V[1]+1),sizeof(double));
knots.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots.cpp://        VV[i] = (double *)calloc(rep->dim_V[1]+1,sizeof(double));
knots.cpp:    teta = (double *)calloc(rep->dim_V[1]+1,sizeof(double));
knots.cpp:    tknots = (double *)calloc(rep->nKnots+1,sizeof(double));
knots.cpp: //   free(rep->eta);
knots.cpp:    teta[pos_idx] = rnorm(0,1/sqrt(rep->preceta),seed);
knots.cpp:    (rep->dim_V[1])++;
knots.cpp:    (rep->nKnots)++;
knots.cpp:    rep->eta = (double *)realloc(rep->eta,sizeof(double)*(rep->dim_V[1]));
knots.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots.cpp:        rep->eta[i] = teta[i];
knots.cpp:    rep->knots = (double *)realloc(rep->knots,sizeof(double)*(rep->nKnots));
knots.cpp:    for (i=0;i<rep->nKnots;i++)
knots.cpp:        rep->knots[i] = tknots[i];
knots.cpp:    rep->V = (double *)realloc(rep->V,rep->dim_V[0]*rep->dim_V[1]*sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[0];i++) {
knots.cpp:        for (j=0;j<rep->dim_V[1];j++) {
knots.cpp:            rep->V[i*rep->dim_V[1]+j] = VV[i*rep->dim_V[1]+j];
knots.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots.cpp://        free(rep->J[i]);
knots.cpp://    free(rep->J);
knots.cpp://    rep->J = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots.cpp: //       rep->J[i] = (double *)realloc(rep->J[i],rep->dim_V[1]*sizeof(double));
knots.cpp://    rep->J[i] = (double *)calloc(rep->dim_V[1],sizeof(double));
knots.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
knots.cpp:    int P = rep->dim_W[1];
knots.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],P);
knots.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots.cpp:    calculate_residuals(rep,rep->P);
knots.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots.cpp:        *full_likelihood += rep->d_Y[i]*rep->residuals[i]*rep->residuals[i];
knots.cpp:    remove = (int)rmultinomial(death_rate,(long)(rep->nKnots-2*sdegree),seed);
knots.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots.cpp://        free(rep->V[i]);
knots.cpp://    free(rep->V);
knots.cpp://    rep->V = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots.cpp: //   for (i=0;i<rep->dim_V[0];i++)
knots.cpp:        rep->V = (double *)realloc(rep->V,rep->dim_V[0]*(rep->dim_V[1]-1)*sizeof(double));
knots.cpp://    rep->V[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots.cpp://        free(rep->J[i]);
knots.cpp://    free(rep->J);
knots.cpp://    rep->J = (double **)calloc(rep->dim_V[0],sizeof(double *));
knots.cpp://    for (i=0;i<rep->dim_V[0];i++)
knots.cpp://        rep->J[i] = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots.cpp:    eta = (double *)calloc(rep->dim_V[1]-1,sizeof(double));
knots.cpp:    tknots = (double *)calloc(rep->nKnots-1,sizeof(double));
knots.cpp:    remove_knot(rep,rep->V,eta,tknots,4,remove);
knots.cpp:    (rep->nKnots)--;
knots.cpp:    (rep->dim_V[1])--;
knots.cpp://    free(rep->eta);
knots.cpp://    rep->eta = (double *)calloc(rep->dim_V[1],sizeof(double));
knots.cpp:    rep->eta = (double *)realloc(rep->eta,rep->dim_V[1]*sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[1];i++)
knots.cpp:        rep->eta[i] = eta[i];
knots.cpp://    free(rep->knots);
knots.cpp://    rep->knots = (double *)calloc(rep->nKnots,sizeof(double));
knots.cpp:    rep->knots = (double *)realloc(rep->knots,rep->nKnots*sizeof(double));
knots.cpp:    for (i=0;i<rep->nKnots;i++)
knots.cpp:        rep->knots[i] = tknots[i];
knots.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
knots.cpp:    int P = rep->dim_W[1];
knots.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],P);
knots.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
knots.cpp:    calculate_residuals(rep,rep->P);
knots.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots.cpp:        *full_likelihood += rep->d_Y[i]*rep->residuals[i]*rep->residuals[i];
knots.cpp:    prior_rate = rgamma(pop->knots,1,seed); // rep->nKnots;
knots.cpp:    calculate_residuals(rep,rep->P);
knots.cpp:    for (i=0;i<rep->dim_X[0];i++)
knots.cpp:        full_likelihood += rep->d_Y[i]*rep->residuals[i]*rep->residuals[i];
knots.cpp:        death_rate = (double *)calloc(rep->nKnots-2*sdegree,sizeof(double));
knots.cpp:        else if (rep->nKnots-sdegree >= max_knots)
knots.cpp:            if (rep->nKnots-2*sdegree > 1) 
knots.cpp:    nKnots = rep->nKnots-2*sdegree;
knots.cpp:            death_rate[i] = log(Birth_rate/prior_rate) + partial_likelihood[i] - full_likelihood; //+ ldens[i] - prior_ldens[i] + log(rep->dim_V[0]-1);
knots.cpp:        if (rep->nKnots==0)
knots.cpp:    for (i=0;i<rep->nKnots;i++) {
knots.cpp:            knots[k] = rep->knots[i];
knots.cpp:    for (j=0;j<rep->dim_V[1];j++) {
knots.cpp:            eta[k] = rep->eta[j];
knots.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots.cpp:    for (i=0;i<rep->dim_V[0];i++) {
knots.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,rep->nKnots-1,&V[i*(rep->dim_V[1]-1)]);
knots.cpp:    for (i=0;i<rep->nKnots;i++) {
knots.cpp:        if (rep->knots[i] < position) {
knots.cpp:            knots[i] = rep->knots[i];
knots.cpp://            printf("i = %d %lf %lf\n",i,rep->knots[i],rep->knots[i+1]);fflush(stdout);
knots.cpp:    for (j=i;j<rep->nKnots;j++)
knots.cpp:        knots[j+1] = rep->knots[j];
knots.cpp:        eta[i] = rep->eta[i];
knots.cpp:    for (i=k;i<rep->dim_V[1]+1;i++)
knots.cpp:        eta[i] = rep->eta[i-1];
knots.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
knots.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots.cpp:    nKnots = rep->nKnots+1;
knots.cpp:    for (i=0;i<rep->dim_V[0];i++)
knots.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,nKnots,&V[i*(rep->dim_V[1]+1)]);
marg_eta_updates.cpp:    for (i=0;i<rep->nKnots;i++) {
marg_eta_updates.cpp:            knots[k] = rep->knots[i];
marg_eta_updates.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:    for (i=0;i<rep->dim_V[0];i++)
marg_eta_updates.cpp:    for (i=0;i<rep->dim_V[0];i++) {
marg_eta_updates.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,rep->nKnots-1,&V[i*(rep->dim_V[1]-1)]);
marg_eta_updates.cpp:   if (rep->nKnots-2*sdegree > 0) {
marg_eta_updates.cpp:        double vareta = 1./rep->preceta;
marg_eta_updates.cpp:        V = (double *)calloc(rep->dim_V[1]*rep->dim_V[0],sizeof(double)); 
marg_eta_updates.cpp:        res = (double *)calloc(rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:        calH(V,rep->V,rep->delta,(const int)rep->dim_V[0],(const int)rep->dim_V[1],(const int)rep->dim_W[1]);
marg_eta_updates.cpp:        adddoubles(V,rep->V,V,(const int)(rep->dim_V[0]*rep->dim_V[1]),-1);
marg_eta_updates.cpp:        marg_res(res,rep->Y,rep->Xbeta,rep->delta,(const int)rep->dim_X[0],(const int)rep->dim_W[1]);
marg_eta_updates.cpp:        double old_ll = marg_ll(res,vareta,rep->d_Y,V,(const int)rep->dim_V[1],(const int)rep->dim_V[0]);
marg_eta_updates.cpp:        int remove = runiform_n(rep->nKnots-2*sdegree,seed) + sdegree;
marg_eta_updates.cpp:        V = (double *)calloc((rep->dim_V[1]-1)*rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:        knots = (double *)calloc(rep->nKnots-1,sizeof(double));
marg_eta_updates.cpp:        double new_ll = marg_ll(res,vareta,rep->d_Y,V,(const int)(rep->dim_V[1]-1),(const int)rep->dim_V[0]);
marg_eta_updates.cpp:        int nKnots = rep->nKnots-2*sdegree;
marg_eta_updates.cpp:        double lprior_ratio = log((double)nKnots/rgamma((double)pop->knots,1,seed)) + log((double)rep->dim_X[0]);
marg_eta_updates.cpp:        double lprop_ratio = log((double)nKnots/(double)rep->dim_X[0]);
marg_eta_updates.cpp:            (rep->dim_V[1])--;
marg_eta_updates.cpp:            (rep->nKnots)--;
marg_eta_updates.cpp:            rep->eta = (double *)realloc(rep->eta,sizeof(double)*(rep->dim_V[1]));
marg_eta_updates.cpp:            rep->knots = (double *)realloc(rep->knots,sizeof(double)*(rep->nKnots));
marg_eta_updates.cpp:            copydouble(rep->knots,knots,(const int)rep->nKnots);
marg_eta_updates.cpp:            rep->V = (double *)realloc(rep->V,rep->dim_V[0]*rep->dim_V[1]*sizeof(double));
marg_eta_updates.cpp:            copydouble(rep->V,V,(const int)(rep->dim_V[0]*rep->dim_V[1]));  
marg_eta_updates.cpp:    for (i=0;i<rep->nKnots;i++) {
marg_eta_updates.cpp:        if (rep->knots[i] < position) {
marg_eta_updates.cpp:            knots[i] = rep->knots[i];
marg_eta_updates.cpp:    for (j=i;j<rep->nKnots;j++)
marg_eta_updates.cpp:        knots[j+1] = rep->knots[j];
marg_eta_updates.cpp:    data = (double *)calloc(rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:    for (i=0;i<rep->dim_V[0];i++)
marg_eta_updates.cpp:    nKnots = rep->nKnots+1;
marg_eta_updates.cpp:    for (i=0;i<rep->dim_V[0];i++)
marg_eta_updates.cpp:        bsplinebasis(0,0,sdegree,data[i],knots,nKnots,&V[i*(rep->dim_V[1]+1)]);
marg_eta_updates.cpp:   if (rep->nKnots-2*sdegree < MAX_KNOTS) {
marg_eta_updates.cpp:        double vareta = 1./rep->preceta;
marg_eta_updates.cpp:        V = (double *)calloc(rep->dim_V[1]*rep->dim_V[0],sizeof(double)); 
marg_eta_updates.cpp:        res = (double *)calloc(rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:        calH(V,rep->V,rep->delta,(const int)rep->dim_V[0],(const int)rep->dim_V[1],(const int)rep->dim_W[1]);
marg_eta_updates.cpp:        adddoubles(V,rep->V,V,(const int)(rep->dim_V[0]*rep->dim_V[1]),-1);
marg_eta_updates.cpp:        marg_res(res,rep->Y,rep->Xbeta,rep->delta,(const int)rep->dim_X[0],(const int)rep->dim_W[1]);
marg_eta_updates.cpp:        double old_ll = marg_ll(res,vareta,rep->d_Y,V,(const int)rep->dim_V[1],(const int)rep->dim_V[0]);
marg_eta_updates.cpp:        double  position = runif_atob(seed,0,rep->dim_V[0]-1);
marg_eta_updates.cpp:        for (int i = sdegree;i<rep->nKnots-sdegree;i++){
marg_eta_updates.cpp:            if (fabs(position-rep->knots[i]) < 0.01) {
marg_eta_updates.cpp:                position = runif_atob(seed,0,rep->dim_V[0]-1);
marg_eta_updates.cpp:        V = (double *)calloc((rep->dim_V[1]+1)*rep->dim_V[0],sizeof(double));
marg_eta_updates.cpp:        knots = (double *)calloc(rep->nKnots+1,sizeof(double));
marg_eta_updates.cpp:        double new_ll = marg_ll(res,vareta,rep->d_Y,V,(const int)(rep->dim_V[1]+1),(const int)rep->dim_V[0]);
marg_eta_updates.cpp:        int nKnots = rep->nKnots-2*sdegree + 1;
marg_eta_updates.cpp:        double lprior_ratio = log(rgamma((double)pop->knots,1,seed)/(double)nKnots) - log((double)rep->dim_X[0]);
marg_eta_updates.cpp:        double lprop_ratio = log((double)rep->dim_X[0]/(double)nKnots);
marg_eta_updates.cpp:            (rep->dim_V[1])++;
marg_eta_updates.cpp:            (rep->nKnots)++;
marg_eta_updates.cpp:            rep->eta = (double *)realloc(rep->eta,sizeof(double)*(rep->dim_V[1]));
marg_eta_updates.cpp:            rep->knots = (double *)realloc(rep->knots,sizeof(double)*(rep->nKnots));
marg_eta_updates.cpp:            copydouble(rep->knots,knots,(const int)rep->nKnots);
marg_eta_updates.cpp:            rep->V = (double *)realloc(rep->V,rep->dim_V[0]*rep->dim_V[1]*sizeof(double));
marg_eta_updates.cpp:            copydouble(rep->V,V,(const int)(rep->dim_V[0]*rep->dim_V[1]));  
mcmc2.cpp:                    fprintf(rep->fout_nknots,"%d ",rep->nKnots-2*sdegree);
mcmc2.cpp:                    fflush(rep->fout_nknots);
mcmc2.cpp:                    for (i=0;i<rep->nKnots-sdegree*2;i++) {
mcmc2.cpp://printf("iter = %d %d\n",iter,rep->nKnots-2*sdegree);fflush(stdout);
mcmc2.cpp:                if (rep->dim_W[1] > 0) {
mcmc2.cpp:                    //    rep->md1 += rep->df_delta1;
mcmc2.cpp:                    //    rep->md2 += rep->df_delta2;
mcmc2.cpp:                  //      rep->tableP[rep->P]++;
mcmc2.cpp:                  //      fprintf(rep->fout_dlm,"%lf %lf %d\n",rep->df_delta1,rep->df_delta2,rep->P);
mcmc2.cpp:                       // rep->md1 /= (double)(BURN_IN/2);
mcmc2.cpp:                       // rep->md2 /= (double)(BURN_IN/2);
mcmc2.cpp:                            fprintf(flog,"%d ",rep->tableP[i]);                          
mcmc2.cpp:                            if (rep->tableP[i] > imax) {
mcmc2.cpp:                                imax = rep->tableP[i];
mcmc2.cpp:                        fflush(rep->fout_dlm);
mcmc2.cpp:                        rewind(rep->fout_dlm);
mcmc2.cpp:                        while (fscanf(rep->fout_dlm,"%lf %lf %d\n",&(rep->df_delta1),&(rep->df_delta2),&(rep->P))!= EOF) {
mcmc2.cpp:                            if (rep->P == j) {
mcmc2.cpp:                                rep->md1 += rep->df_delta1;
mcmc2.cpp:                                rep->md2 += rep->df_delta2;
mcmc2.cpp:                        fclose(rep->fout_dlm);
mcmc2.cpp:                        rep->df_delta1 = rep->md1/(double)cntj;
mcmc2.cpp:                        rep->df_delta2 = rep->md2/(double)cntj;
mcmc2.cpp:                        rep->P = j;
mcmc2.cpp:                        rep->dim_W[1] = rep->P;
mcmc2.cpp:                        calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);                       
mcmc2.cpp:                        fprintf(flog,"\n%lf \t \%lf \t %d %d\n",rep->df_delta1,rep->df_delta2,rep->P,cntj);
mcmc2.cpp:                        calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp:                        calculate_residuals(rep,rep->P);
mcmc2.cpp:                    fprintf(flog,"iter = %6d\t Sub %d, Rep %d \t int knots = %d",iter,isub,irep,rep->nKnots-2*sdegree);
mcmc2.cpp:                    fprintf(flog,"\t precY0 = %10.6lf \t preceta = %10.6lf\n",rep->d_Y[rep->dim_X[0]-1],rep->preceta);
mcmc2.cpp:                    fprintf(flog,"\t df_delta1 = %10.6lf \t df_delta2 = %10.6lf \t P = %3d\n",rep->df_delta1,rep->df_delta2,rep->P);
mcmc2.cpp:                        rt = (double)rep->accept[0]/(double)rep->attempt[0];
mcmc2.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[0]),0.35);
mcmc2.cpp:                        rep->accept[0] = rep->attempt[0] = 0;
mcmc2.cpp:                        fprintf(flog,"\t\t rt = %lf proposal = %lf\n",rt,rep->prop_sd[0]);
mcmc2.cpp:                        rt = (double)rep->accept[1]/(double)rep->attempt[1];
mcmc2.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[1]),0.35);
mcmc2.cpp:                        rt = (double)rep->accept[3]/(double)rep->attempt[3];
mcmc2.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[3]),0.35);
mcmc2.cpp:                        rep->accept[3] = rep->attempt[3] = 0;
mcmc2.cpp:                        fprintf(flog,"\t\t rt = %lf proposal = %lf\n",rt,rep->prop_sd[3]);
mcmc2.cpp:                    for (i=rep->P;i<rep->dim_W[0];i++) {
mcmc2.cpp:                        for (j=0;j<rep->dim_W[1];j++) {
mcmc2.cpp:                            rep->mdelta[i*rep->dim_W[1]+j] += rep->delta[i*rep->dim_W[1]+j];
mcmc2.cpp:                            rep->mdelta2[i*rep->dim_W[1]+j] += rep->delta[i*rep->dim_W[1]+j]*rep->delta[i*rep->dim_W[1]+j];
mcmc2.cpp:                    for (i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:                        rep->md_Y[i] += 1./sqrt(rep->d_Y[i]);
mcmc2.cpp:                        rep->sd_Y[i] += 1./rep->d_Y[i];
mcmc2.cpp:                    for (i=0;i<rep->dim_V[1];i++)
mcmc2.cpp:                        fprintf(rep->fout_eta,"%lf ",rep->eta[i]);
mcmc2.cpp:                    fprintf(rep->fout_eta,"\n");
mcmc2.cpp:                    for (i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:                        rep->mean_res[i] += rep->residuals[i];
mcmc2.cpp:                        rep->mean_d_Y[i] += rep->d_Y[i];
mcmc2.cpp:                        rep->mean_fit[i] += rep->Y[i] - rep->residuals[i];
mcmc2.cpp:                    for (i=0;i<rep->dim_X[0];i++)
mcmc2.cpp:                        rep->mXbeta[i] += rep->Xbeta[i];
mcmc2.cpp:                    for (i=0;i<rep->dim_V[0];i++)
mcmc2.cpp:                        rep->mVeta[i] += rep->Veta[i];
mcmc2.cpp:                    for (i=0;i<rep->dim_W[0];i++)
mcmc2.cpp:                        rep->mWdelta[i] += rep->Wdelta[i];
mcmc2.cpp:                    fprintf(rep->fout_dlm,"%lf %lf %d\n",rep->df_delta1,rep->df_delta2,rep->P);
mcmc2.cpp://                    fprintf(rep->fout_nknots,"%d ",rep->nKnots-2*sdegree);
mcmc2.cpp:                    for (i=sdegree;i<rep->nKnots-sdegree;i++)
mcmc2.cpp:                        fprintf(rep->fout_knots,"%lf ",rep->knots[i]);
mcmc2.cpp:                    fprintf(rep->fout_knots,"\n");  
mcmc2.cpp:            fclose(rep->fout_dlm);
mcmc2.cpp:            fclose(rep->fout_eta);
mcmc2.cpp:            fclose(rep->fout_nknots);
mcmc2.cpp:            fclose(rep->fout_knots);
mcmc2.cpp:            for (i=rep->P;i<rep->dim_W[0];i++) {
mcmc2.cpp:                for (j=0;j<rep->dim_W[1];j++) {
mcmc2.cpp:                    rep->mdelta[i*rep->dim_W[1]+j] /= (double)(MAX_ITER-BURN_IN);
mcmc2.cpp:                    fprintf(rep->fout_delta,"%lf ",rep->mdelta[i*rep->dim_W[1]+j]);
mcmc2.cpp:                fprintf(rep->fout_delta,"\n");                  
mcmc2.cpp:            fclose(rep->fout_delta);
mcmc2.cpp:            for (i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:                    rep->md_Y[i] /= (double)(MAX_ITER-BURN_IN);
mcmc2.cpp:                    fprintf(rep->fout_prec,"%lf ",rep->md_Y[i]);
mcmc2.cpp:            fprintf(rep->fout_prec,"\n");                  
mcmc2.cpp:            fclose(rep->fout_prec);
mcmc2.cpp:            for (i=0;i<rep->dim_W[0];i++)
mcmc2.cpp:                fprintf(rep->fout_wdelta,"%lf ",rep->mWdelta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc2.cpp:            fclose(rep->fout_wdelta);
mcmc2.cpp:            for (i=0;i<rep->dim_V[0];i++)
mcmc2.cpp:                fprintf(rep->fout_veta,"%lf ",rep->mVeta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc2.cpp:            fclose(rep->fout_veta);
mcmc2.cpp:            for (i=0;i<rep->dim_X[0];i++)
mcmc2.cpp:                fprintf(rep->fout_Xbeta,"%lf ",rep->mXbeta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc2.cpp:            fclose(rep->fout_Xbeta);
mcmc2.cpp:            for (i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:                rep->mean_res[i] /= ((MAX_ITER-BURN_IN));
mcmc2.cpp:                rep->mean_fit[i] /= ((MAX_ITER-BURN_IN));
mcmc2.cpp:                rep->mean_d_Y[i] /= ((MAX_ITER-BURN_IN));
mcmc2.cpp:            for (i=rep->P;i<rep->dim_X[0];i++)
mcmc2.cpp:                DE += mlogsqrt2pi + sqrt(rep->mean_d_Y[i]) - 0.5*(rep->mean_res[i])*(rep->mean_res[i]*rep->mean_d_Y[i]);
mcmc2.cpp:            for (i=0;i<rep->dim_X[0];i++)
mcmc2.cpp:                fprintf(rep->fout_res,"%lf ",rep->mean_res[i]);
mcmc2.cpp:            fclose(rep->fout_res);
mcmc2.cpp:           for (i=0;i<rep->dim_X[0];i++)
mcmc2.cpp:                fprintf(rep->fout_fit,"%lf ",rep->mean_fit[i]);
mcmc2.cpp:            fclose(rep->fout_fit);
mcmc2.cpp:    a = (double)rep->P/2. + ALPHA;
mcmc2.cpp:    for (int i=0;i<rep->P;i++)
mcmc2.cpp:        b += (rep->Y[i]-rep->Veta[i])*(rep->Y[i]-rep->Veta[i]);
mcmc2.cpp:    rep->precYstart = rgamma(a,b,seed);
mcmc2.cpp:    for (int i=0;i<rep->P;i++)
mcmc2.cpp:        rep->d_Y[i] = rep->precYstart;
mcmc2.cpp:        rep->residuals[i] = rep->Y[i] - rep->Veta[i] - rep->Xbeta[i];
mcmc2.cpp:    for (i=P;i<rep->dim_X[0];i++)
mcmc2.cpp:        rep->residuals[i] = rep->Y[i] - (rep->Veta[i] + rep->Wdelta[i] + rep->Xbeta[i]);
mcmc2.cpp:        rep->residuals[i] = rep->Y[i] - rep->Veta[i] - rep->Xbeta[i];
mcmc2.cpp:    for (i=P;i<rep->dim_X[0];i++)
mcmc2.cpp:        rep->residuals[i] = rep->Y[i] - (rep->Veta[i] + rep->Wm[i] + rep->Xbeta[i]);
mcmc2.cpp:        rep->residuals1[i] = 0;
mcmc2.cpp:    for (i=P;i<rep->dim_X[0];i++) {
mcmc2.cpp:        rep->residuals1[i] = rep->Y[i] - rep->Wdelta[i] - rep->Veta[i];
mcmc2.cpp:        rep->residuals2[i] = 0;
mcmc2.cpp:    for (int i=P;i<rep->dim_X[0];i++) {
mcmc2.cpp:        rep->residuals2[i] = rep->Y[i] - rep->Wdelta[i] - rep->Xbeta[i] - rep->Veta[i];
mcmc2.cpp:    for (int i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:        rep->residuals3[i] = rep->Y[i] -  rep->Xbeta[i] - rep->Veta[i];
mcmc2.cpp:        rep->residuals4[i] = rep->Y[i];
mcmc2.cpp:   for (int i=P;i<rep->dim_V[0];i++)
mcmc2.cpp:        rep->residuals4[i] = rep->Y[i] - rep->Xbeta[i] - rep->Wdelta[i];
mcmc2.cpp:        rep->residuals5[i] = rep->Y[i];
mcmc2.cpp:   for (int i=P;i<rep->dim_V[0];i++)
mcmc2.cpp:        rep->residuals5[i] = rep->Y[i] - Wm[i];
mcmc2.cpp://        rep->residuals5[i] = rep->Y[i] - rep->Wdelta[i];
mcmc2.cpp:    for (int i=0;i<rep->dim_V[1];i++)
mcmc2.cpp:            b += rep->eta[i]*rep->eta[i];
mcmc2.cpp:    a = 0.5*rep->dim_V[1] + ALPHA;
mcmc2.cpp:        rep->preceta = tmp;
mcmc2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
mcmc2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp:    calculate_marginal_residuals(rep,rep->P);
mcmc2.cpp:    ncol = (rep->dim_X[1] + rep->dim_V[1]);
mcmc2.cpp:    V = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc2.cpp:    J = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc2.cpp:    X = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc2.cpp:    for (i=0;i<rep->dim_V[0];i++)
mcmc2.cpp:        for (j=0;j<rep->dim_X[1];j++)
mcmc2.cpp:            X[i*ncol+j] = rep->X[i*rep->dim_X[1]+j];
mcmc2.cpp:     for (i=0;i<rep->dim_V[0];i++)
mcmc2.cpp:        for (j=rep->dim_X[1];j<ncol;j++)
mcmc2.cpp:            X[i*ncol+j] = rep->V[i*rep->dim_V[1]+j-rep->dim_X[1]];
mcmc2.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc2.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc2.cpp:        betaeta[i] = rep->eta[i-rep->dim_X[1]];
mcmc2.cpp:    calH(J,X,rep->m,(const int)rep->dim_V[0],(const int)ncol,(const int)rep->P);
mcmc2.cpp:    Jbe = (double *)calloc(rep->dim_V[0],sizeof(double));
mcmc2.cpp:    calAx(Jbe,J,betaeta,(const int)rep->dim_V[0],(const int)ncol);
mcmc2.cpp:    calW2(rep->W,rep->Y,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
mcmc2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp:    calculate_res5(rep,rep->Wm,rep->P);
mcmc2.cpp:    for (i=0;i<rep->dim_V[0];i++)
mcmc2.cpp:    double *Qinv = (double *)calloc(rep->dim_V[0],sizeof(double));
mcmc2.cpp:    for (i=0;i<rep->P;i++)
mcmc2.cpp:        Qinv[i] = rep->d_Y[i];
mcmc2.cpp:    for (i=rep->P;i<rep->dim_V[0];i++)
mcmc2.cpp:    calApVinvX(M,V,rep->residuals5,Qinv,rep->dim_V[0],ncol);
mcmc2.cpp:    calApVinvA(VpV,V,Qinv,(const int)rep->dim_V[0],(const int)ncol);
mcmc2.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc2.cpp:        VpV[i*ncol+i] += rep->preceta;
mcmc2.cpp:        int Nrow = rep->dim_X[1];
mcmc2.cpp:        fprintf(flog,"rep->preceta = %lf\n",rep->preceta);
mcmc2.cpp:        for (i=0;i<rep->dim_V[1];i++)
mcmc2.cpp:            fprintf(flog,"%lf\n",rep->eta[i]);
mcmc2.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc2.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc2.cpp:        rep->eta[i-rep->dim_X[1]] = mean[i];
mcmc2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
mcmc2.cpp:    calAx(rep->Xbeta,rep->X,sub->beta,(const int)rep->dim_X[0],(const int)rep->dim_X[1]);
mcmc2.cpp://    calculate_marginal_residuals(rep,rep->P);
mcmc2.cpp:    for (i=0;i<rep->dim_X[0];i++) {
mcmc2.cpp:        importance_dens += log(Qinv[i]) - Qinv[i]*rep->residuals[i]*rep->residuals[i];
mcmc2.cpp://         printf("imp = %lf Qinv = %g res = %g\n",importance_dens,Qinv[i],rep->residuals[i]);
mcmc2.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
mcmc2.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp:    calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp:    for (i=0;i<rep->P;i++)
mcmc2.cpp:        Qinv[i] = rep->d_Y[i];
mcmc2.cpp:    for (i=rep->P;i<rep->dim_V[0];i++)
mcmc2.cpp:    calculate_marginal_residuals(rep,rep->P);
mcmc2.cpp:    for (i=0;i<rep->dim_X[0];i++)
mcmc2.cpp:        true_dens += log(Qinv[i]) - Qinv[i]*rep->residuals[i]*rep->residuals[i];
mcmc2.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc2.cpp:    for (i=0;i<rep->dim_V[1];i++)
mcmc2.cpp:        rep->eta[i] *= ratio;
mcmc2.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
mcmc2.cpp:    calAx(rep->Xbeta,rep->X,sub->beta,(const int)rep->dim_X[0],(const int)rep->dim_X[1]);   
mcmc2.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc2.cpp: //   calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc2.cpp: //   calculate_marginal_residuals(rep,rep->P);
mcmc2.cpp:    calculate_residuals(rep,rep->P);
mcmc2.cpp:    for (i=rep->P;i<rep->dim_X[0];i++)
mcmc2.cpp:            tmp += mlogsqrt2pi + sqrt(rep->d_Y[i]) - 0.5*rep->d_Y[i]*(rep->residuals[i])*(rep->residuals[i]);
mcmc.cpp:                fprintf(rep->fout_nknots,"%d ",rep->nKnots-2*sdegree);fflush(rep->fout_nknots);
mcmc.cpp:                 for (i=0;i<rep->nKnots-sdegree*2;i++) {
mcmc.cpp:                if (!(iter%2) && (rep->dim_W[1] > 0)) {
mcmc.cpp://printf("nKnots = %d \n",rep->dim_V[1]);
mcmc.cpp:                        rt = (double)rep->accept[0]/(double)rep->attempt[0];
mcmc.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[0]),0.35);
mcmc.cpp:                        rep->accept[0] = rep->attempt[0] = 0;
mcmc.cpp:                            fprintf(flog,"\t\t rt = %lf proposal = %lf\n",rt,rep->prop_sd[0]);
mcmc.cpp:                        rt = (double)rep->accept[1]/(double)rep->attempt[1];
mcmc.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[1]),0.35);
mcmc.cpp:                        rep->accept[1] = rep->attempt[1] = 0;
mcmc.cpp:                        rt = (double)rep->accept[3]/(double)rep->attempt[3];
mcmc.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[3]),0.35);
mcmc.cpp:                        rep->accept[3] = rep->attempt[3] = 0;
mcmc.cpp:                            fprintf(flog,"\t\t rt = %lf proposal = %lf\n",rt,rep->prop_sd[3]);
mcmc.cpp:                        rt = (double)rep->accept[2]/(double)rep->attempt[2];
mcmc.cpp: //                       fprintf(flog,"rt = %lf %d\n",rt,rep->accept[2]);
mcmc.cpp:                        adjust_acceptance2(rt,&(rep->prop_sd[2]),0.35);
mcmc.cpp:                        rep->accept[2] = rep->attempt[2] = 0;
mcmc.cpp:                                fprintf(flog,"\t\t rt = %lf proposal = %lf mean = %lf\n\n",rt,rep->prop_sd[2],rep->mhrf);
mcmc.cpp:                    fprintf(flog,"iter = %6d\t Sub %d, Rep %d \t int knots = %d",iter,isub,irep,rep->nKnots-2*sdegree);
mcmc.cpp:                    fprintf(flog,"\t precY0 = %10.6lf \t preceta = %10.6lf\n",rep->d_Y[rep->dim_X[0]-1],rep->preceta);
mcmc.cpp:                    fprintf(flog,"\t df_delta1 = %10.6lf \t df_delta2 = %10.6lf \t P = %3d\n",rep->df_delta1,rep->df_delta2,rep->P);
mcmc.cpp:                    fprintf(flog,"\t cnt = %d, pi = %lf\n",rep->dim_X[0]-rep->d_Ycnt,rep->pi);
mcmc.cpp:                    for (i=rep->P;i<rep->dim_W[0];i++) {
mcmc.cpp:                        for (j=0;j<rep->dim_W[1];j++) {
mcmc.cpp:                            rep->mdelta[i*maxP+j] += rep->delta[i*rep->dim_W[1]+j];
mcmc.cpp:                            rep->mdelta2[i*rep->dim_W[1]+j] += rep->delta[i*rep->dim_W[1]+j]*rep->delta[i*rep->dim_W[1]+j];
mcmc.cpp:                        for (j=rep->dim_W[1];j<maxP;j++)
mcmc.cpp:                            rep->mdelta[i*maxP+j] = 0;
mcmc.cpp:                    for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:                        fprintf(ftmp,"%lf ",rep->Veta[i]);
mcmc.cpp:                    for (i=0;i<rep->dim_W[0];i++)
mcmc.cpp:                        fprintf(ftmp,"%lf ",rep->Wdelta[i]);
mcmc.cpp:                    for (i=0;i<rep->dim_X[1];i++)
mcmc.cpp:                    for (i=0;i<rep->dim_X[0];i++) {
mcmc.cpp:                        rep->md_Y[i] += 1./sqrt(rep->d_Y[i]);
mcmc.cpp:                        rep->sd_Y[i] += rep->d_Y[i];
mcmc.cpp:                    for (i=0;i<rep->dim_V[1];i++)
mcmc.cpp:                        fprintf(rep->fout_eta,"%lf ",rep->eta[i]);
mcmc.cpp:                    fprintf(rep->fout_eta,"\n");
mcmc.cpp:                    for (i=0;i<rep->dim_X[0];i++) {
mcmc.cpp:                        rep->mean_fit[i] += rep->Y[i] - rep->residuals[i];
mcmc.cpp:   //                     rep->std_res[i]  += rep->residuals[i]*sqrt(rep->d_Y[i]);
mcmc.cpp:                        rep->mean_res[i] += rep->residuals[i];
mcmc.cpp:                        rep->mean_d_Y[i] += rep->d_Y[i];
mcmc.cpp:                    for (i=0;i<rep->dim_X[0];i++)
mcmc.cpp:                        rep->mXbeta[i] += rep->Xbeta[i];
mcmc.cpp:                    for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:                        rep->mVeta[i] += rep->Veta[i];
mcmc.cpp:                    for (i=0;i<rep->dim_W[0];i++)
mcmc.cpp:                        rep->mWdelta[i] += rep->Wdelta[i];
mcmc.cpp:                    fprintf(rep->fout_dlm,"%lf %lf %d\n",rep->df_delta1,rep->df_delta2,rep->P);
mcmc.cpp:                    fprintf(rep->fout_nknots,"%d ",rep->nKnots-2*sdegree);
mcmc.cpp:                    for (i=sdegree;i<rep->nKnots-sdegree;i++)
mcmc.cpp:                        fprintf(rep->fout_knots,"%lf ",rep->knots[i]);
mcmc.cpp:                    fprintf(rep->fout_knots,"\n");  
mcmc.cpp:                        fprintf(rep->fout_beta,"%lf ",rep->beta[i]);
mcmc.cpp:                    fprintf(rep->fout_beta,"\n");  
mcmc.cpp:            fclose(rep->fout_dlm);
mcmc.cpp:            fclose(rep->fout_eta);
mcmc.cpp:            fclose(rep->fout_beta);
mcmc.cpp:            fclose(rep->fout_nknots);
mcmc.cpp:            fclose(rep->fout_knots);
mcmc.cpp:            for (i=0;i<rep->dim_W[0];i++) {
mcmc.cpp:                    rep->mdelta[i*maxP+j] /= (double)(MAX_ITER-BURN_IN);
mcmc.cpp:                    fprintf(rep->fout_delta,"%lf ",rep->mdelta[i*maxP+j]);
mcmc.cpp:                fprintf(rep->fout_delta,"\n");                  
mcmc.cpp:            fclose(rep->fout_delta);
mcmc.cpp:            for (i=0;i<rep->dim_X[0];i++) {
mcmc.cpp:                    rep->md_Y[i] /= (double)(MAX_ITER-BURN_IN);
mcmc.cpp:                    rep->sd_Y[i] =  sqrt((double)(MAX_ITER-BURN_IN)/rep->sd_Y[i]);
mcmc.cpp:                    fprintf(rep->fout_stdev,"%lf ",rep->sd_Y[i]);
mcmc.cpp:            fprintf(rep->fout_stdev,"\n");                  
mcmc.cpp:            fclose(rep->fout_stdev);
mcmc.cpp:            for (i=0;i<rep->dim_W[0];i++)
mcmc.cpp:                fprintf(rep->fout_wdelta,"%lf ",rep->mWdelta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc.cpp:            fclose(rep->fout_wdelta);
mcmc.cpp:            for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:                fprintf(rep->fout_veta,"%lf ",rep->mVeta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc.cpp:            fclose(rep->fout_veta);
mcmc.cpp:            for (i=0;i<rep->dim_X[0];i++)
mcmc.cpp:                fprintf(rep->fout_Xbeta,"%lf ",rep->mXbeta[i]/(double)((MAX_ITER-BURN_IN)));
mcmc.cpp:            fclose(rep->fout_Xbeta);
mcmc.cpp:            for (i=0;i<rep->dim_X[0];i++) {
mcmc.cpp:                rep->mean_res[i] /= ((MAX_ITER-BURN_IN));
mcmc.cpp:                rep->mean_fit[i] /= ((MAX_ITER-BURN_IN));
mcmc.cpp:                rep->mean_d_Y[i] /= ((MAX_ITER-BURN_IN));
mcmc.cpp:                rep->std_res[i] = rep->mean_res[i]/rep->sd_Y[i];
mcmc.cpp:            for (i=maxP;i<rep->dim_X[0];i++)
mcmc.cpp:                DE += mlogsqrt2pi + sqrt(rep->mean_d_Y[i]) - 0.5*(rep->mean_res[i])*(rep->mean_res[i]*rep->mean_d_Y[i]);
mcmc.cpp:            for (i=0;i<rep->dim_X[0];i++)
mcmc.cpp:                fprintf(rep->fout_res,"%lf ",rep->mean_res[i]);
mcmc.cpp:            fclose(rep->fout_res);
mcmc.cpp:            for (i=0;i<rep->dim_X[0];i++)
mcmc.cpp:                fprintf(rep->fout_stdres,"%lf ",rep->std_res[i]);
mcmc.cpp:            fclose(rep->fout_stdres);
mcmc.cpp:           for (i=0;i<rep->dim_X[0];i++)
mcmc.cpp:                fprintf(rep->fout_fit,"%lf ",rep->mean_fit[i]);
mcmc.cpp:            fclose(rep->fout_fit);
mcmc.cpp:    a = (double)rep->P/2. + ALPHA;
mcmc.cpp:    for (int i=0;i<rep->P;i++)
mcmc.cpp:        b += (rep->Y[i]-rep->Veta[i])*(rep->Y[i]-rep->Veta[i]);
mcmc.cpp:    rep->precYstart = rgamma(a,b,seed);
mcmc.cpp:    for (int i=0;i<rep->P;i++)
mcmc.cpp:        rep->d_Y[i] = rep->precYstart;
mcmc.cpp:    prob = rep->pi;
mcmc.cpp:    int P = rep->P;
mcmc.cpp:    int N = rep->dim_X[0];
mcmc.cpp:    rep->d_Ycnt = 0;
mcmc.cpp:        if (rep->dY[t]) {
mcmc.cpp:            phi = rep->d_Y[t];
mcmc.cpp:        ratio = rep->residuals[t]*rep->residuals[t];//*rep->d_Y[t];
mcmc.cpp:        ratio = (rep->LY*(1.-prob)/prob) *exp(0.5*phi*(1.-rep->LY)*ratio);
mcmc.cpp:            rep->dY[t] = 1;
mcmc.cpp:            (rep->d_Ycnt)++;
mcmc.cpp:            rep->dY[t] = 0;
mcmc.cpp:    int N = rep->dim_X[0];
mcmc.cpp:    int P = rep->P;
mcmc.cpp:    int cnt = rep->d_Ycnt;
mcmc.cpp:    rep->pi = rbeta(ALPHA+cnt,BETA+N-P-cnt,seed);
mcmc.cpp:    N = rep->dim_X[0];
mcmc.cpp:    P = rep->P;
mcmc.cpp:        if (rep->dY[i])
mcmc.cpp:            b += rep->residuals[i]*rep->residuals[i];
mcmc.cpp:            b += rep->residuals[i]*rep->residuals[i]*rep->LY;
mcmc.cpp:        if (rep->dY[i])
mcmc.cpp:            factor = rep->LY;
mcmc.cpp:        rep->d_Y[i] = factor*tmp;
mcmc.cpp:        rep->residuals[i] = rep->Y[i] - rep->Veta[i] - rep->Xbeta[i];
mcmc.cpp:    for (i=P;i<rep->dim_X[0];i++)
mcmc.cpp:        rep->residuals[i] = rep->Y[i] - (rep->Veta[i] + rep->Wdelta[i] + rep->Xbeta[i]);
mcmc.cpp:        rep->residuals[i] = rep->Y[i] - rep->Veta[i] - rep->Xbeta[i];
mcmc.cpp:    for (i=P;i<rep->dim_X[0];i++)
mcmc.cpp:        rep->residuals[i] = rep->Y[i] - (rep->Veta[i] + rep->Wm[i] + rep->Xbeta[i]);
mcmc.cpp:        rep->residuals1[i] = 0;
mcmc.cpp:    for (i=P;i<rep->dim_X[0];i++) {
mcmc.cpp:        rep->residuals1[i] = rep->Y[i] - rep->Wdelta[i] - rep->Veta[i];
mcmc.cpp:        rep->residuals2[i] = 0;
mcmc.cpp:    for (int i=P;i<rep->dim_X[0];i++) {
mcmc.cpp:        rep->residuals2[i] = rep->Y[i] - rep->Wdelta[i] - rep->Xbeta[i] - rep->Veta[i];
mcmc.cpp:    for (int i=0;i<rep->dim_X[0];i++) {
mcmc.cpp:        rep->residuals3[i] = rep->Y[i] -  rep->Xbeta[i] - rep->Veta[i];
mcmc.cpp:        rep->residuals4[i] = rep->Y[i];
mcmc.cpp:   for (int i=P;i<rep->dim_V[0];i++)
mcmc.cpp:        rep->residuals4[i] = rep->Y[i] - rep->Xbeta[i] - rep->Wdelta[i];
mcmc.cpp:        rep->residuals5[i] = rep->Y[i];
mcmc.cpp:    for (int i=P;i<rep->dim_V[0];i++)
mcmc.cpp:        rep->residuals5[i] = rep->Y[i] - rep->Wdelta[i];
mcmc.cpp:    for (int i=0;i<rep->dim_V[1];i++)
mcmc.cpp:            b += rep->eta[i]*rep->eta[i];
mcmc.cpp:    a = 0.5*rep->dim_V[1] + ALPHA;
mcmc.cpp:        rep->preceta = tmp;
mcmc.cpp:                        rss += (rep->beta[j+is*pop->Nb]-Xb[j+is*pop->Nb])*(rep->beta[j+is*pop->Nb]-Xb[j+is*pop->Nb]);
mcmc.cpp:                        rss += (rep->beta[j+is*pop->Nb]-sub[i].beta[j+is*pop->Nb])*(rep->beta[j+is*pop->Nb]-sub[i].beta[j+is*pop->Nb]);
mcmc.cpp:    ncol = (rep->dim_X[1] + rep->dim_V[1]);
mcmc.cpp:    V = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc.cpp:    J = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc.cpp:    X = (double *)calloc(rep->dim_V[0]*ncol,sizeof(double));
mcmc.cpp:    for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:        for (j=0;j<rep->dim_X[1];j++)
mcmc.cpp:            X[i*ncol+j] = rep->X[i*rep->dim_X[1]+j];
mcmc.cpp:     for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:        for (j=rep->dim_X[1];j<ncol;j++)
mcmc.cpp:            X[i*ncol+j] = rep->V[i*rep->dim_V[1]+j-rep->dim_X[1]];
mcmc.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc.cpp:        betaeta[i] = rep->beta[i];
mcmc.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc.cpp:        betaeta[i] = rep->eta[i-rep->dim_X[1]];
mcmc.cpp:     calH(J,X,rep->delta,(const int)rep->dim_V[0],(const int)ncol,(const int)rep->P);
mcmc.cpp:    Jbe = (double *)calloc(rep->dim_V[0],sizeof(double));
mcmc.cpp:    calAx(Jbe,J,betaeta,(const int)rep->dim_V[0],(const int)ncol);
mcmc.cpp:    calculate_res5(rep,rep->P);
mcmc.cpp:    for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:        rep->residuals5[i] -= Jbe[i];
mcmc.cpp:    for (i=0;i<rep->dim_V[0];i++)
mcmc.cpp:    calApVinvX(M,V,rep->residuals5,rep->d_Y,rep->dim_V[0],ncol);
mcmc.cpp:    calApVinvA(VpV,V,rep->d_Y,(const int)rep->dim_V[0],(const int)ncol);
mcmc.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc.cpp:        VpV[i*ncol+i] += rep->preceta;
mcmc.cpp:            int Nrow = rep->dim_X[1];
mcmc.cpp:    for (i=0;i<rep->dim_X[1];i++)
mcmc.cpp:        rep->beta[i] = mean[i];
mcmc.cpp:    for (i=rep->dim_X[1];i<ncol;i++)
mcmc.cpp:        rep->eta[i-rep->dim_X[1]] = mean[i];
mcmc.cpp:    calAx(rep->Veta,rep->V,rep->eta,(const int)rep->dim_V[0],(const int)rep->dim_V[1]);
mcmc.cpp:    calAx(rep->Xbeta,rep->X,rep->beta,(const int)rep->dim_X[0],(const int)rep->dim_X[1]);
mcmc.cpp:    calW(rep->W,rep->Y,rep->Xbeta,rep->Veta,(const int)rep->dim_W[0],(const int)rep->dim_W[1],rep->P);
mcmc.cpp:    calWdelta(rep->Wdelta,rep->W,rep->delta,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc.cpp://      calWdelta(rep->Wm,rep->W,rep->m,(const int)rep->dim_W[0],(const int)rep->dim_W[1]);
mcmc.cpp://     calculate_marginal_residuals(rep,rep->P);
mcmc.cpp:    calculate_residuals(rep,rep->P);
mcmc.cpp:    for (i=maxP;i<rep->dim_X[0];i++)
mcmc.cpp:            tmp += mlogsqrt2pi + sqrt(rep->d_Y[i]) - 0.5*rep->d_Y[i]*(rep->residuals[i])*(rep->residuals[i]);
